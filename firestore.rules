/**
 * Core Philosophy: This ruleset enforces a two-tiered access model designed for a multi-tenant SaaS application.
 * 1. Organization Ownership: Each organization is treated as a distinct tenant with its own data silo. An authenticated user, whose UID matches the organization's ID, has full CRUD access to their own data tree.
 * 2. Super Admin Oversight: A special "super admin" role grants read-only access across all organization data for administrative and support purposes. This role is managed via a dedicated 'roles_admin' collection.
 *
 * Data Structure: The primary data is hierarchically organized under `/organizations/{organizationId}`. This structure contains all organization-specific data, including profiles, receipts, and logs. Top-level collections like `systemErrorLogs` and `roles_admin` are reserved for system-level functions and are inaccessible to regular organization users.
 *
 * Key Security Decisions:
 * - Super admin privileges are granted by the existence of a document in `/roles_admin/{userId}`, a secure and common Database-Based Access Control (DBAC) pattern.
 * - Client-side listing of roles or system logs is strictly forbidden to prevent information leakage.
 * - All write operations from clients to system-level collections (e.g., `systemErrorLogs`) are disabled by default, assuming such logs are generated by trusted backend services.
 * - The default security posture is denial; access is only granted through explicit rules.
 *
 * Denormalization for Authorization: To ensure fast and secure access control, the `organizationId` is denormalized and stored on each `receipt` document. This allows security rules for receipts to validate ownership directly without performing costly and slow `get()` calls up the document hierarchy. Subcollections under receipts (`emailLogs`, `smsLogs`) inherit access from their parent's path.
 *
 * Structural Segregation: Data with different security needs is kept in separate collections. For example, sensitive `systemErrorLogs` are in their own top-level collection, completely isolated from tenant data in `/organizations`, which simplifies the rules and prevents access-control logic from becoming overly complex.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the user has super admin privileges.
     * Admin status is granted by the existence of a document in the roles_admin collection.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the currently authenticated user owns the specified organization's data.
     * The model assumes the user's UID is the same as the organization's document ID.
     */
    function isOrgOwner(organizationId) {
      return isSignedIn() && request.auth.uid == organizationId;
    }

    /**
     * A secure wrapper for update and delete operations.
     * It combines an ownership check with a verification that the document exists.
     */
    function isExistingResourceOwner(organizationId) {
      return isOrgOwner(organizationId) && resource != null;
    }

    /**
     * Validates that an incoming document has a valid 'organizationId' on create.
     */
    function hasValidOrgDataOnCreate(organizationId) {
      return request.resource.data.organizationId == organizationId;
    }

    /**
     * Enforces that the 'organizationId' field is immutable on update.
     */
    function isOrgIdImmutable() {
      return request.resource.data.organizationId == resource.data.organizationId;
    }
    
    /**
     * Validates that the receipt's 'organizationId' field matches the path on create.
     */
    function hasValidReceiptDataOnCreate(organizationId) {
      return request.resource.data.organizationId == organizationId;
    }

    /**
     * Enforces that the receipt's 'organizationId' field is immutable on update.
     */
    function isReceiptOrgIdImmutable() {
      return request.resource.data.organizationId == resource.data.organizationId;
    }
    
    /**
     * Validates that a log's 'receiptId' field matches the path on create.
     */
    function hasValidLogDataOnCreate(receiptId) {
        return request.resource.data.receiptId == receiptId;
    }

    /**
     * Enforces that a log's 'receiptId' field is immutable on update.
     */
    function isLogReceiptIdImmutable() {
        return request.resource.data.receiptId == resource.data.receiptId;
    }

    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description Manages super admin roles. This collection should only be managed by
     *              trusted server-side processes or the Firebase Console.
     * @path /roles_admin/{userId}
     * @allow (none) - No client-side operations are permitted.
     * @deny  (read/write) - Any user attempting to read or write roles from the client.
     * @principle Protects critical authorization metadata from any client modification or inspection.
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }

    /**
     * @description Stores system-level error logs. Writable only by backend services.
     * @path /systemErrorLogs/{systemErrorLogId}
     * @allow (get/list) - A super admin can read error logs for debugging.
     * @deny  (create/update/delete) - All client-side writes are forbidden.
     * @principle Segregates sensitive system data and protects it from client modification.
     */
    match /systemErrorLogs/{systemErrorLogId} {
      allow get, list: if isSuperAdmin();
      allow write: if false;
    }

    /**
     * @description Defines rules for organization profile documents.
     * @path /organizations/{organizationId}
     * @allow (read/write) - An organization can manage its own document. auth.uid must match organizationId.
     * @allow (read) - A super admin can read any organization's profile.
     * @deny  (write) - A user trying to create a profile for a different organizationId.
     * @principle Enforces a strict data ownership model, isolating tenant data.
     */
    match /organizations/{organizationId} {
      allow get, list: if isOrgOwner(organizationId) || isSuperAdmin();
      allow create: if isOrgOwner(organizationId) && request.resource.data.id == organizationId;
      allow update: if isExistingResourceOwner(organizationId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingResourceOwner(organizationId);
    }
    
    /**
     * @description Defines rules for contacts, which are subcollections of an organization.
     * @path /organizations/{organizationId}/contacts/{contactId}
     * @allow (read/write) - The owning organization can manage its contacts.
     * @allow (read) - A super admin can read any organization's contacts.
     * @deny  (create) - An organization trying to create a contact with a mismatched 'organizationId'.
     * @principle Enforces data ownership and isolation for customer contact information.
     */
    match /organizations/{organizationId}/contacts/{contactId} {
      allow get, list, create, update, delete: if isOrgOwner(organizationId);
      allow get, list: if isSuperAdmin();
    }


    /**
     * @description Defines rules for receipts, which are subcollections of an organization.
     * @path /organizations/{organizationId}/receipts/{receiptId}
     * @allow (read/write) - The owning organization can manage its receipts.
     * @allow (read) - A super admin can read any organization's receipts.
     * @deny  (create) - An organization trying to create a receipt with a mismatched 'organizationId' field.
     * @principle Utilizes denormalized ownership data (`organizationId`) for efficient and secure access control.
     */
    match /organizations/{organizationId}/receipts/{receiptId} {
      allow get, list: if isOrgOwner(organizationId) || isSuperAdmin();
      allow create: if isOrgOwner(organizationId) && hasValidReceiptDataOnCreate(organizationId);
      allow update: if isExistingResourceOwner(organizationId) && isReceiptOrgIdImmutable();
      allow delete: if isExistingResourceOwner(organizationId);
    }

    /**
     * @description Defines rules for email logs, nested under a specific receipt.
     * @path /organizations/{organizationId}/receipts/{receiptId}/emailLogs/{emailLogId}
     * @allow (read/write) - The owning organization can manage logs for its receipts.
     * @allow (read) - A super admin can read any email log.
     * @deny  (update) - An attempt to change the 'receiptId' to re-parent the log.
     * @principle Inherits ownership from the path, ensuring logs are bound to the correct organization.
     */
    match /organizations/{organizationId}/receipts/{receiptId}/emailLogs/{emailLogId} {
      allow get, list: if isOrgOwner(organizationId) || isSuperAdmin();
      allow create: if isOrgOwner(organizationId) && hasValidLogDataOnCreate(receiptId);
      allow update: if isExistingResourceOwner(organizationId) && isLogReceiptIdImmutable();
      allow delete: if isExistingResourceOwner(organizationId);
    }

    /**
     * @description Defines rules for SMS logs, nested under a specific receipt.
     * @path /organizations/{organizationId}/receipts/{receiptId}/smsLogs/{smsLogId}
     * @allow (read/write) - The owning organization can manage logs for its receipts.
     * @allow (read) - A super admin can read any SMS log.
     * @deny  (update) - An attempt to change the 'receiptId' to re-parent the log.
     * @principle Inherits ownership from the path, ensuring logs are bound to the correct organization.
     */
    match /organizations/{organizationId}/receipts/{receiptId}/smsLogs/{smsLogId} {
      allow get, list: if isOrgOwner(organizationId) || isSuperAdmin();
      allow create: if isOrgOwner(organizationId) && hasValidLogDataOnCreate(receiptId);
      allow update: if isExistingResourceOwner(organizationId) && isLogReceiptIdImmutable();
      allow delete: if isExistingResourceOwner(organizationId);
    }
  }
}
    